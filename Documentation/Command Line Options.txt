
// –––––––––––––––––––––––––––––––––––––––––
H1 Command Line Options

p	When invoking zasm you can append options to it on the command line, most notably the name of the source file.

pre	zasm [options] [-i] inputfile [[-l] listfile|dir] [[-o] outfile|dir]

p	default output dir = source dir
  	default list dir = output dir

p.b	Typical invocations
pre	zasm -uwy emuf_rom.asm


H4	Command line options

pre	-u  --opcodes   include object code in list file
	-w  --labels    append label listing to list file
	-y  --cycles    include cpu clock cycles in list file
	-b  --bin       write output to binary file (default)
	-x  --hex       write output in intel hex format
	-s  --s19       write output in motorola s-record format
	-z  --clean     clear intermediate files, e.g. compiled c files
	-e  --compare   compare own output to existing output file
	-T  --test      run self test (requires developer source tree)
	--maxerrors=NN  set maximum for reported errors (default=30, max=999)
	-o0             don't write output file
	-l0             don't write list file
	--z80           target Zilog Z80 (default)
	--z180          target Z180 / HD64180: enable additional instructions
	--8080          target Intel 8080: limit registers and instructions to 8080
	--asm8080       target Intel 8080: use 8080 assembler syntax
	-v0 -v1 -v2     verbosity of messages to stderr (0=off, 1=default, 2=more)
	--ixcbr2 | …xh  enable ill. instructions like 'set b,(ix+d),r' or 'set b,xh'
	--dotnames      allow label names starting with a dot '.'
	--reqcolon      colon ':' after program label definitions required
	                => label definitions and instructions may start in any column
	--casefold      label names are case insensitive (asm8080: implied)
	--flatops       no operator precedence: evaluate strictly from left to right
	-c path/to/cc   set path to c compiler (default: sdcc in $PATH)
	-t path/to/dir  set path to temp dir for c compiler (default: output dir)
	-I path/to/dir  set path to c system header dir (default: sdcc default)
	-L path/to/dir  set path to standard library dir (default: none)

p	Options can be packed, e.g. '-uwy' is the same as giving 3 separate options.
	Also, due to the way zasm parses it's arguments, you can even include options which require an additional argument in this way:
	
pre $> zasm -cuwy /bin/sdcc emuf.asm

p	Here the 'c' will pull the '/bin/sdcc'.

H5	-u --opcodes
p	Request a list file which includes the generated bytes.

pre	0215:         	;/pub/Develop/Projects/zasm-4.0/Test/main.c:11: int mult(int a, int b)
	0215:         	; ---------------------------------
	0215:         	; Function mult
	0215:         	; ---------------------------------
	0215:         	_mult:
	0215: DDE5    		push	ix
	0217: DD210000		ld		ix,#0
	021B: DD39    		add		ix,sp
	021D:         	;/pub/Develop/Projects/zasm-4.0/Test/main.c:13: return a * b;
	021D: DD6E06  		ld		l,6 (ix)
	0220: DD6607  		ld		h,7 (ix)
	0223: E5      		push	hl
	0224: DD6E04  		ld		l,4 (ix)
	0227: DD6605  		ld		h,5 (ix)
	022A: E5      		push	hl
	022B: CDA003  		call	__mulint
	022E: F1      		pop		af
	022F: F1      		pop		af
	0230: DDE1    		pop		ix
	0232: C9      		ret


H5	-w  --labels    
p	Request a labels summary at end of the list file. Also lists the defined code and data segments.

pre	; +++ segments +++
	 
	#CODE PROG_HEADER:  start=0     len=17    flag=0
	#CODE PROG_DATA:    start=0     len=55    flag=255
	...
	#CODE _CABS:        start=36246 len=0    
	#CODE _GSFINAL:     start=36246 len=0    
	#CODE _INITIALIZER: start=36246 len=12   
	#DATA _DATA:        start=23296 len=53   
	#DATA _INITIALIZED: start=23349 len=203  
	 
	; +++ global symbols +++
	 
	CODE_DATA           = $5DC0 =  24000  CODE_DATA    test-tap.asm:107 (unused)
	CODE_HEADER         = $0000 =      0  CODE_HEADER  test-tap.asm:95 (unused)
	_CABS               = $8D96 =  36246  _CABS        test-tap.asm:120 (unused)
	_CODE               = $717E =  29054  _CODE        test-tap.asm:119 (unused)
	_DABS               = $5C00 =  23552  _DABS        test-tap.asm:137 (unused)
	_DATA               = $5B00 =  23296  _DATA        test-tap.asm:135
	_GSFINAL            = $8D96 =  36246  _GSFINAL     test-tap.asm:121 (unused)
	...
	

H5	-y  --cycles    
p	Requests to include accumulated cpu cycles in the list file. 
p	'accumulated' means that zasm does not print the individual execution time for each instruction but sums it up for a thread of code. Program labels are supposed to be entry points from arbitrary positions in code and therefore the sum is reset at every program label. Instructions with varying execution time are given with their run-through time in first place and the branching or repeating time as a second value.
	
pre	                        ; initialize initialized data:
	 
	5DC0: 010C00   [10]     		ld	bc,_INITIALIZER_len	; length of segment _INITIALIZER
	5DC3: 11355B   [20]     		ld	de,_INITIALIZED		; start of segment _INITIALIZED
	5DC6: 21968D   [30]     		ld	hl,_INITIALIZER		; start of segment _INITIALIZER
	5DC9: 78       [34]     		ld	a,b
	5DCA: B1       [38]     		or	c
	5DCB: 2802     [45|50]  		jr	z,$+4
	5DCD: EDB0     [61|21]  		ldir

	
H5	-b  --bin       
p	Request to write the output file in binary format. This is the default.

H5	-x  --hex       
p	Request to write the output file in Intel Hex format. This is only allowed for target ROM (the default) or target BIN.

pre	:200000003E00ED79ED79ED793E40ED793EDAED793E37ED79ED780F30FB3A1027D370ED787B
	:090020000F0F30FADB70321027DB
	:00000001FF

H5	-s  --s19       
p	Request to write the output file in Motorola S-Record format. This is only allowed for target ROM (the default) or target BIN.
p	This format supports a header and zasm uses it to store the source file name and assembly date. Since it is encoded as hex data, it is not directly readable in the example below:

pre	S00F00007320323031352D30312D313178
	S12C00003E00ED79ED79ED793E40ED793EDAED793E37ED79ED780F30FB3A1027D370ED780F0F30FADB7032102772
	S5030001FB
	S9030000FC

H5	-z  --clean     
p	This requests zasm to erase all cached files from the c compiler. These files are stored in subdirectory 's/' in the selected temp directory, which is by default the source file's directory.

H5	-e  --compare   
p	This allows to check whether the output for a certain source file has changed: The output file of the assembly is not written but compared to the already existing output file of an older assembly. The main purpose for this option is to support zasm's self test, but you may use it to check your source for code-effective modifications without the need to supply a different output file name and to run cmp against the two files.

pre	$> zasm -e zx82.asm "ROMs/zx82 standard rom for ram/zxsp rom for ram.rom"
	--> mismatch at $33FC: old=$AA, new=$00
	--> mismatch at $33FD: old=$04, new=$00
	assemble: 10665 lines
	time: 0.1129 sec.
	 
	zasm: 2 errors

p	In this example i have compiled the original source of the ZX Spectrum rom and compared it with a modified rom, where a routine which dumps unwanted data at address 0x0000 has been modified to dump it somewhere else, (when i look at the output this seems to be address 0x04AA) so that the rom file can be used in ram (if you have ram at address 0x0000).

p	If the files match, then simply an ok message is printed and no files are written. If they don't match, then zasm stores a list file with generated opcodes so that you can immediately scrutinize the generated code at the losted addresses.



H5	-T  --test      
p	Run zasm's built-in self test. This requires that you have the test directory at hand, because zasm will compile a bunch of source files and compare the output with the files present there. You can append the directory path to the command, else zasm will try the standard location relative to it's own path.

pre	$> zasm -T ./Test

H5	--maxerrors=NN  
	maxerrors
p	Set the maximum amount of errors after which zasm will bail out. Default value is 30 errors. Some errors, especially after assembler directives starting with '#', are 'fatal' and will always immediately terminate assembly regardless of this setting.
	
H5	-o0             
p	Use this if you don't want the output file to be created, e.g. if you just want to recreate the list file. This will save you some milli seconds…

H5	-l0             
p	Use this option if you don't want a list file to be created. Normally, if no list file specific option is given, a 'plain' list file is genertaed which is mostly the same as the source file, plus any included files, plus markers for any occured error.

H5	--z80           
p	Set the target cpu to Z80. This is the default.
	The same effect can be achieved with the pseudo instruction '.z80' at the start of your source.

H5	--z180          
p	Set the target cpu to Z180 / HD64180. This enables additional instructions and disables all illegal instructions, because the Z180 traps them.
	Same effect as with pseudo instruction '.z180' at the start of the source file.

H5	--8080          
	i8080
p	Set the target cpu to the Intel 8080. This disables all additional Z80 instructions. The source must still be in Z80 syntax. Use this option if you want to verify that your program will also run on the 8080 cpu, e.g. for CP/M.
	
H5	--asm8080       
p	Announce that this is an assembler source in the Intel 8080 assembler format with these 'weird mnemonics'. This option implies the option --casefold. 
	Same effect as with pseudo instruction '.8080' at the start of the source file.


H5	-v[0,1,2]       
	v0,v1,v2
p	Set verbosity of messages to stderr. Default is -v1.
p	By default some warnings, all errors and a '123 errors' / 'no errors' message are printed.
	With -v2 some more warnings are printed.
	With -v0 nothing is printed.

	
H5	--ixcbr2 and --ixcbxh  
	ixcbr2 xh, ixcbr2, ixcbxh
p	IXCB is used here as a mnenonic for the prefix IX or IY plus prefix 0xCB instructions like 'rr', 'bit', 'set' and 'res'. These are allowed for those opcodes which use the '(hl)' register only. But people have found out what they do when you use one of the other, regular registers: They may additionally copy the result into the selected register or they may, if you use register 'h' or 'l', access the upper or lower byte of the index register. 
p	What a CPU does depends on it's hardware. Original Zilog Z80 CPUs should behave as for --ixcbr2. Others allow the access to the index register halves, some just behave as for '(hl)' for all other registers as well and some, like the Z180, even trap all illegal instruction.
p	Option --ixcbr2 enables the 'second register target' opcodes like
pre	 	set 0,(ix+0),b
p	and option --ixcbxh enables the 'index register halves' opcodes like
pre	 	set 0,xh
p	Obviously they are mutually exclusive.


H5	--dotnames      
p	Allow label names to start with a dot.
p.magenta	<i>This is an option to adopt to various syntax variants found in the wild.</i>
p	First dots were not allowed in label names. Then some assemblers prepended a dot to the pseudo instructions to easily distinguish them from normal instructions and label names, so they could start at any column of a source line. Having seen that, some people immediately developed the need to start their label names with a dot as well…
p	Normally, without this option, only pseudo instructions like '.ds' or '.org' can start with a dot. Then they may be written at any position of a source line irregardly of the --reqcolon setting. 
p	With this setting the limitations described at --reqcolons also applies to pseudo instructions starting with a dot because the dot no longer makes them special and implicitely a non-label.

p	The following example is only valid source with --dotnames and --reqcolon:
pre	.org	0				; starts in column 0 => requires --reqcolon 
		.ds 0x66			; one of the original dot named pseudo instructions
		jp	.nmi_handler	; requires --dotname

p	Of course you couls clean up your source as well…


H5	--reqcolon      
p	Select syntax variant where colons ':' are required after program label definitions.
p.magenta	<i>This is an option to adopt to various syntax variants found in the wild.</i>
p	Normally colons are not required and the assembler decides whether a name is a label definition or something else by the position where it starts: label names must start in column 1 and instructions must be preceded by some space.

p	This example must not be compiled with --reqcolon or --dotnames:
pre	.org 0					; due to the dot this pseudo instruction is allowed in column 1
	foo		equ	0xF00		; label definition
	bar:	and	a			; program label def and a instruction
			jp	foo			; instruction
	shelf	db	0			; program label def and a pseudo instruction

p	But some source files don't obey this widely accepted rule and put instructions in column 1 or – actually seen – start label definitions indented with some tabs. 
p	As long as only pseudo instructions starting with a dot are put in column 1 and option --dotnames is not required, this is no problem. In all other cases you need this option --reqcolon and, of course, then colons are required after program label definitions, but still not after other label definitions with 'equ' and the like:

p	This example must be compiled with --reqcolon:
pre	; funny indented:
	org 0						; 'org' would be recognized as a label without --reqcolon
		foo		equ	0xF00		; label definition
		bar:	and	a			; program label def and a instruction
	jp	foo						; instruction
		shelf:					; program label definition
	.db	0						; a pseudo instruction

			

H5	--casefold      
p	Tell the assembler that label names are case insensitive and that the source does not distinguish between uppercase and lowercase writing of label names.
p	Note: instruction and register names are always case insensitive.
p	This option is implied by --asm8080.
p	Normally label names are case sensitive or people just tend to just write them allways the same.
p.magenta	<i>This is an option to adopt to various syntax variants found in the wild.</i>

H5	--flatops       
p	Evaluate expressions strictly from left to right, disobeying any operator precedence.
p	Old assemblers sometimes didn't know about operator precedence and were designed this way for simplicity.
p	Use this option if error messages about byte values or offsets out of range are reported by zasm and these expressions make more sense when evaluated this way.

p	Normal operator precedence in zasm is:

pre	unary ! ~ + –  ▶︎  >> <<  ▶︎  & | ^  ▶︎  * / %  ▶︎  + –  ▶︎  > >= etc.  ▶︎  && ||  ▶︎  ?:

p	Note that this is not the precedence as defined for c. <b>B-)</b>. The hierarchy of operators in c is very bad.


+	command line options for c compiler.txt


                    





