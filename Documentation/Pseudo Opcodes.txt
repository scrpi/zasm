

//-----------------------------------------------------------------
h2	Pseudo instructions

p	Pseudo instructions are instructions like 'org' or 'defs', which are written at the place of a Z80 assembler instruction but which are not Z80 instructions. Some pseudo instructions generate code, others don't.
p	Z80 and pseudo instructions must not start in column 1, because then the assembler will assume a label definition. Instructions are always preceded by 'white space', at minimum one space or one tab.




//-----------------------------------------------------------------
h3	org

pre	org <value>

p	The org pseudo instruction defines a new logical origin for the generated code. The code generation pointer is not moved, but all subsequent generated code is generated for the new logical origin. This comes in handy if you write routines or a jump table which you want to move around in memory later. All labels defined after the org pseudo instruction refer to the new logical origin. The dollar sign '$' in expressions refers to the logical origin too. Normally you don't need the org pseudo instruction, because you set the origin when you define a code segment with the #code assembler directive.

p	If you actually want to move the code generation pointer to that new position and fill the unused space with $00 or the like, then you can use defs:


h5	Example: advance code deposition pointer

pre
	; ------------------------------------------------------
				...					; some code
				pop		af
				ret

				defs	$66 - $		; advance to address $66
	nmi_vek:	...

	; ------------------------------------------------------



h5	Example: relocated jump table
	relocate, relocatable, relocator

pre
	; ------------------------------------------------------
				...					; some code
				ccf
				ret

	rom_table:	org		$FE00		; label based on old org
	ram_table:						; label based on new org

	putchar:	jp		putchar_rom
	puttext:	jp		puttext_rom
	getchar:	jp		getchar_rom
	getline:	jp		getline_rom

	table_size:	equ		$ - ram_table

	; back to old origin
				org		rom_table + table_size

	gizmo:		ld		de,ram_table
				ld		hl,rom_table
				ld		bc,table_size
				ldir

				ld	a,0				; more code
				...

	; ------------------------------------------------------


p	<b>note:</b> in version 3.0.5 and 3.0.6 the org pseudo instruction behaved differently!



//-----------------------------------------------------------------
h3	data

p.i	TODO: the following is for zasm version 3.0.

pre	<label>: data <value>

p	The pseudo instruction 'data' assigns the current value of the data segment pointer to the <label> and reserves <value> bytes from the data segment defined with the #data assembler directive. If data allocation exceeds the size given in the #data assembler directive, the assembler reports an error.

h5	Example:

pre	...
	#data	$4000,$100
	...

	ticks	data	3
	foo		data	4
	bar		data	4
	cheese	data	$20
	...


h3	defw, dw
	defw, dw

pre	defw <value>[,<value>...]
	dw   <value>[,<value>...]

p	Same as 'defb' but for words (double bytes). Words are stored with their least significant byte first! This means, $1234 is stored as $34, $12 and 'ab' is stored as 'b','a'. If you don't like this, try using the defm pseudo instruction.


h3	defb, defm, db, dm
	defb, db, defm, dm

p	Since version 3.0.16 the functionality of defb and defm are merged. Any vombination of data which was valid for either of both can now be used with any of both.

pre	defb <value>[,<value>...]
	db   <value>[,<value>...]

p	The defb pseudo instruction evaluates the argument expressions and puts them one byte after the other into the code segment. 

pre	defm <text>[,<text>]
	dm   <text>[,<text>]

p	Stores a string of text into the code segment. The text string may be given in the following formats:

pre	$12345678....   packed hex string
	12345678h       packed hex string
	'text'          text string, delimited by <'>, must not contain <'>
	"text"          text string, delimited by <">, must not contain <">

p	The hex bytes or ascii bytes are stored in the same order as they appear in the string, e.g. $1234 is stored as $12,$34 and 'ab' is stored as 'a','b'.

p	The last byte of a packed hex string or a text string may be modified by an expression; commonly used is setting bit 7 of the last character of a message:

pre	defm   "this is my message"+$80

p	There are three predefined names for text strings:

pre	__date__        current date:     "Jan.31.96"
	__time__        current time:     "23:56:30"
	__file__        current file name "filename.ext"



//-----------------------------------------------------------------
h3	defs, ds
	defs, ds

pre	defs <value1>[,<value2>]
	ds   <value1>[,<value2>]

p	This pseudo instruction inserts a block of <value1> bytes into the code segment. The default fill pattern is $FF for ROMs and $00 for all other target formats. If you append a <value2>, this byte is used as pattern instead.

p	Within a #head segment the default values for the header data are used by defs if no second value is given.


h3	defl, equ
	defl, equ

pre	<label>:  defl  <value>
	<label>:  equ   <value>

p	These two pseudo instructions do quite the same and are used to assign a value to a name. The expression needs not to be evaluatable in the first pass but if possible it is.

