{ h0={ Text="zasm - Z80 Assembler",
Keywords={ "zasm_z80_assembl" } },
toc={ Text="Table of contents" },
p={ Text="<i>Last updated: 2014-12-29 15:02:56.</i>" },
p={ Text="Note: internal links in this document are generated automatically. Some links may not be meaningful. ;-)" },
h1={ Text="General Information",
Keywords={ "general_information" } },
h5={ Text="About zasm",
Keywords={ "about_zasm" } },
p={ Text="<b><i>zasm</i></b> is a multiple pass assembler for the historic 8-bit CPU <b><i>Zilog Z80</i></b> and it's variants, e.g. Intel 8080 (it's predecessor) or Hitachi HD64180." },
h5={ Text="System requirements",
Keywords={ "syst_requirement" } },
p={ Text="<b><i>zasm</i></b> is available for Unix-like operating systems like OSX, Linux, BSD." },
h5={ Text="Download pages",
Keywords={ "download_pag",
"download" } },
p={ Text="<http://k1.spdns.de/Develop/projects/zasm/Distributions/>" },
p={ Text="<http://k1.spdns.de/Git/zasm-4.0.git>" },
p={ Text="<http://k1.spdns.de/Git/Libraries.git>" },
h5={ Text="Online Assembler",
Keywords={ "onlin_assembl" } },
p={ Text="I have also created a page with a version of zasm which can be used online:" },
p={ Text="<http://k1.spdns.de/cgi-bin/zasm.cgi>" },
h5={ Text="Bug reports",
Keywords={ "bug_report",
"bug" } },
p={ Text="Please send bug reports to <a href=\"mailto:zasm@little-bat.de\">zasm@little-bat.de</a>." },
h5={ Text="Copyright",
Keywords={ "copyright" } },
p={ Text="<b><i>zasm</i></b> Z80 assembler, copyright © 1994-2014 Günter Woigk, <a href=\"mailto:kio@little-bat.de\">kio@little-bat.de</a>" },
h5={ Text="Disclaimer of Warranties",
Keywords={ "disclaim_of_warranti" } },
p={ Text="This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE." },
p={ Text="The copyright holder makes no representations about the suitability of this software for any purpose. It is provided \"as is\" without express or implied warranty." },
p={ Text="THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE." },
h5={ Text="Permissions",
Keywords={ "permission" } },
p={ Text="Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that this copyright notice and the disclaimer of warranties and this permission notice appear in supporting documentation, and that the name of the copyright holder not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission." },
h1={ Text="Command Line Options",
Keywords={ "command_lin_option",
"option" } },
p={ Text="When invoking zasm you can append options to it on the command line, most notably the name of the source file." },
pre={ Text="zasm [options] [-i] inputfile [[-l] listfile|dir] [[-o] outfile|dir]" },
p={ Class="b",
Text="Typical invocations" },
pre={ Text="zasm -uwy emuf_rom.asm" },
p={ Class="b",
Text="Options" },
pre={ Text="default output dir = source dir\ndefault list dir   = output dir\n \n-u  --opcodes   include object code in list file\n-w  --labels    append label listing to list file\n-y  --cycles    include cpu clock cycles in list file\n-b  --bin       write output to binary file (default)\n-x  --hex       write output in intel hex format\n-s  --s19       write output in motorola s-record format\n-z  --clean     clear intermediate files, e.g. cached compiled c files\n-o0             don't write output file\n-l0             don't write list file\n--ixcbr2        enable illegal instructions like 'set b,(ix+d),r'\n--ixcbxh        enable illegal instructions like 'set b,xh'\n--8080          limit instruction set to Intel 8080 cpu; use z80 asm syntax\n--8080regs      limit instruction set and reserved register names\n                this allows to use z80 register names like ix or xh to be used as label names.\n--hd64180       enable Hitachi HD64180 added instructions\n-v[0,1,2]       verbosity of messages to stderr (0=off,1=default,2=more)\n-c path/to/cc   set path to c compiler               default: sdcc in $PATH\n-t path/to/dir  set path to temp dir for c compiler  default: output dir\n-I path/to/dir  set path to c system header dir      default: sdcc default\n-L path/to/dir  set path to standard library dir     default: none" },
h1={ Text="List File",
Keywords={ "list_fil",
"listing" } },
p={ Text="zasm generates a list file, except if command line option -l0 is given." },
p={ Text="Option '-u' includes the generated opcode in the list file.<br>Option '-w' enables a labels listing at the end of the list file.<br>Option '-y' includes accumulated cpu cycles in the list file." },
h5={ Text="Plain listing",
Keywords={ "plain_listing" } },
pre={ Text="NMI:    push af\n        push hl\n        ld   hl,($5cb0)\n\n        LD   A,H                ;falls HL=0, dann Kaltstart\n        OR   L\n        JR   NZ,M0070           ;sonst passiert nichts\n        JP   (HL)\nM0070:  POP  HL\n        POP  AF\n        RETN\n\nNEXZEI: LD   HL,(CHADD)         ;Programmzeiger erhoehen\nM0077:       INC HL\nM0078:       LD (CHADD),HL      ;Adr. des naechsten zu\n                                ;interpret. Zeichens\n        LD   A,(HL)             ;neues Zeichen laden\n        RET" },
h5={ Text="Listing with object code",
Keywords={ "listing_with_object_cod" } },
pre={ Text="0131: 110100    calcspeed:  ld   de,1       ; pre-adjust\n0134: 210040                ld   hl,tickercell\n0137: 76                    halt\n0138: 7E                    ld   a,(hl)\n0139: 0605      cs1         ld   b,5        ; 7\n013B: 05        cs2         dec  b          ; 5*4\n013C: C23B01                jp   nz,cs2     ; 5*10\n013F: 13                    inc  de         ; 6\n0140: BE                    cp   a,(hl)     ; 7\n0141: CA3901                jp   z,cs1      ; 12\n0144: EB                    ex   hl,de\n0145:           ; this took hl*100 ticks for 1/60 sec\n0145:           ;  = hl*6,000 ticks for 1 sec\n0145: 110600                ld   de,6\n0148: CDB000                call mult\n014B:           ;  = hl*1,000 ticks for 1 sec\n014B: 11E803                ld   de,1000\n014E: CDC900                call divide\n0151:           ;  = hl*1,000,000 + de*1,000 ticks\n0151: C9                    ret" },
h5={ Text="Listing with object code and cpu cycles",
Keywords={ "listing_with_object_cod" } },
p={ Text="Cpu cycles are accumulated from the last label position. Branching opcodes are given with their run-through time and the branching time. Opcodes like LDIR also show the time for a loop.<br>This example is taken from a file generated by sdcc, so don't mind the unusual syntax for immediate arguments and local labels." },
pre={ Text="67A3:                   00102$:\n67A3:                   ;/Develop/Projects/zasm/lib/___fsgt.c:71: if (fl1.l<0 && fl2.l<0) {\n67A3: 210400   [10]         ld  hl,#0x0004\n67A6: 39       [21]         add hl,sp\n67A7: 56       [28]         ld  d,(hl)\n67A8: 23       [34]         inc hl\n67A9: 5E       [41]         ld  e,(hl)\n67AA: 23       [47]         inc hl\n67AB: 4E       [54]         ld  c,(hl)\n67AC: 23       [60]         inc hl\n67AD: 66       [67]         ld  h,(hl)\n67AE: CB7C     [75]         bit 7, h\n67B0: 2849     [82|87]      jr  Z,00106$\n67B2: 210000   [92]         ld  hl,#0x0000\n67B5: 39       [103]        add hl,sp\n67B6: 56       [110]        ld  d,(hl)\n67B7: 23       [116]        inc hl\n67B8: 5E       [123]        ld  e,(hl)\n67B9: 23       [129]        inc hl\n67BA: 4E       [136]        ld  c,(hl)\n67BB: 23       [142]        inc hl\n67BC: 66       [149]        ld  h,(hl)\n67BD: CB7C     [157]        bit 7, h\n67BF: 283A     [164|169]    jr  Z,00106$" },
h5={ Text="Label listing",
Keywords={ "label_listing" } },
p={ Text="This section lists the defined code and data segments and the global and all local labels (if any).<br>For each label zasm lists the value or whether it is invalid (not defined), the segment it is defined in, the source file it is defined in and the source line and whether it is unused.<br>In this example no code segment was defined and all labels reside in the default segment which is currently named \"(DEFAULT)\" which may look a little bit odd." },
pre={ Text="; +++ segments +++\n \n#CODE (DEFAULT): start=0     len=1684\n \n; +++ global symbols +++\n \nhd64180               = $0001 =      1  (DEFAULT) :1 (unused)\nloop2                 = $0249 =    585  (DEFAULT) test-opcodes.asm:636\nn                     = $0040 =     64  (DEFAULT) test-opcodes.asm:593\nn1                    = $0001 =      1  (DEFAULT) test-opcodes.asm:1357\nn16                   = $0010 =     16  (DEFAULT) test-opcodes.asm:1358\nn6                    = $0006 =      6  (DEFAULT) test-opcodes.asm:1356\nnn                    = $4142 =  16706  (DEFAULT) test-opcodes.asm:592\ntest_addressing_modes = $0001 =      1  (DEFAULT) test-opcodes.asm:14\ntest_compound_opcodes = $0001 =      1  (DEFAULT) test-opcodes.asm:15\ntest_expressions      = $0001 =      1  (DEFAULT) test-opcodes.asm:13\ntest_fails            = $0001 =      1  (DEFAULT) test-opcodes.asm:16\n \n; +++ local symbols +++\n \nanton   = $0014 =     20  (DEFAULT) test-opcodes.asm:41 (unused)\nn20     = $0014 =     20  (DEFAULT) test-opcodes.asm:37\nn5      = $0005 =      5  (DEFAULT) test-opcodes.asm:36\n \n; +++ local symbols +++\n \n(DEFAULT)$1 = $0055 =     85  (DEFAULT) test-opcodes.asm:229\nn6          = $0006 =      6  (DEFAULT) test-opcodes.asm:262\nnn          = $0040 =     64  (DEFAULT) test-opcodes.asm:261" },
h5={ Text="Errors",
Keywords={ "error" } },
p={ Text="Errors are marked with <tt><b>*** error ***</b></tt> in the list file. The assembler will abort if too many errors occur." },
p={ Text="If you have only a single source file and you encounter only a few errors and you didn't enable additional fields in the list file then you can move the source into the trash, rename the list file and work on it as your new source file. You can easily find all the <tt><b>*** error ***</b></tt>s and correct them, then start over again. But be careful that the list file is not truncated before actually deleting it. Note: the list file is always truncated at the #end directive, if used." },
p={ Text="If you suspect the assembler is generating wrong object code, you can include the object code in the listing. Then you can easily verify the generated code. If there really is a bug, send a bug report to <A HREF=\"mailto:zasm@little-bat.de\">Kio</A>." },
h1={ Text="Source files",
Keywords={ "sourc_fil" } },
h2={ Text="Source Format",
Keywords={ "sourc_format",
"zasm_expect_your_sourc" } },
p={ Text="ZASM supports the typical layout for Z80 assembler source files, that is, it expects one instruction per line. Comments start with a semicolon \";\" and label definitions start in column 1. Assembler directives start with a hash \"#\" in column 1." },
p={ Text="Though not strictly required it is recommended to declare the target and to define at least one code segment as shown below." },
h5={ Text="Example file:",
Keywords={ "exampl_fil" } },
pre={ Text="; example file\n#target rom                 ; our target is a rom or eprom\n#code   rom, 0, 0x4000      ; define a code segment of 16kB with name 'rom'\n        org     0           ; set logical code address (redundant)\n\nRESET   di                  ; define label 'RESET' and opcode 'DI' at that address\n        ld      sp,8000h    ; next is opcode to set the stack pointer: 'LD SP,8000h'\n        jp      _init_code  ; resume system start somewhere\n        defs    8-$         ; RST8 must start at address 8 => add required space\nRST8    jp      _rst_8      ; jump somewhere\n        defs    16-$        ; RST16 must start at address 16 => add required space\n; ..." },
h2={ Text="Assembler directives",
Keywords={ "assembl_directiv" } },
p={ Text="Assembler directives are instructions to the assembler itself.<br>They all start in column 1 with a hash '#'." },
h3={ Text="#target",
Keywords={ "#target" } },
pre={ Text="#target <name>" },
p={ Text="The #target directive defines the kind of output file. If no #target directive is given in the source, then zasm will default to a rom file. The #target directive must occur before any #code definition and any opcode. Best put it directly at the start of the source. The <name> defines the extension of the output file. Depending on the desired target your source must consist of multiple #code segments. See section about target files." },
h5={ Text="<name> is one of:",
Keywords={ "<name>_is_on_of" } },
pre={ Text="bin     plain binary data, presumably to be loaded into ram\nrom     plain binary data, presumably for a rom\nsna     ZX Spectrum NMI snapshot\nz80     ZX Spectrum snapshot\ntap     ZX Spectrum or Jupiter Ace tape file\no       ZX80 tape file\n80      ZX80 tape file\np       ZX81 tape file\n81      ZX81 tape file\np81     ZX81 tape file\nace     Jupiter Ace snapshot file" },
p={ Text="Only target bin and rom can be written as Intel hex or Motorola S-Record file. All other file types can only be written as binary file." },
h5={ Text="Example:",
Keywords={ "exampl" } },
pre={ Text="#target rom\n;\n#code   rom,0,4000h\n;\n; <-- your code goes here -->\n;\n#end" },
h3={ Text="#code",
Keywords={ "#cod" } },
pre={ Text="#code <name>,<start>,<size>,<flags>" },
p={ Text="This defines a code segment where the generated code will be stored. At least one #code segment should be defined. Depending on the desired target your source must consist of multiple #code segments. See section about target files." },
p={ Text="Arguments may be left unspecified from right to left. If you need to specify the size but not the address, you can use '*' to mark an argument as unspecified, e.g.:" },
pre={ Text="#code   BLOCK1, *, 0x400    ; size = 1kB but at 'floating' address; no flag" },
p={ Text="If you define more than one code segment, then the segments (and thus the code therein) will be appended in the output file in the sequence of definition. Typically you define all used segments at the start of your source file and then later re-enter the segments as required. The following is an example as it might be used if you also include c sources:" },
pre={ Text="#code   _BOOT,0             ; segment with Reset, RST and NMI vectors\n#code   _GSINIT             ; init code: the compiler adds some code here and there as required\n#code   _HOME               ; code that must not be put in a bank switched part of memory.\n#code   _CODE               ; most code and const data go here\n#code   _INITIALIZER        ; initializer for initialized data in ram" },
p={ Text="The <name> can be chosen freely, but must be a valid label name. zasm generates a label for the start address of each segment. If you include c source, then the c compiler requires the above code segments to be defined." },
p={ Text="The <start> address is required for the first segment only or it will default to 0. Following segments will be automatically assigned start addresses without gap. The <start> address defines the assumed 'physical' address for the segment, the address where it is visible to the cpu. In most cases this does nothing more that also setting the 'logical' address for the code. <start> does not insert any space." },
p={ Text="You can use the <start> address if you have a rom which is paged into the Z80 address space. e.g. a 32k rom which consists of 2 pages might be defined like this:" },
pre={ Text="#target ROM\n#code   PAGE1,0,0x4000\n#code   PAGE2,0,0x4000" },
p={ Text="If given, the <size> defines the size for this segment. If you store less bytes in it, then the segment will be padded up to this size with the default fill byte: 0xff for rom and 0x00 for any other target. If your code exceeds the size, then the assembler will generate an error." },
p={ Text="The 3rd argument is not required and actually not allowed in most cases. But some targets require a flag for the code segment, e.g. #target tap requires a flag byte for each tape block." },
p={ Text="A code segment can be re-entered by using the #code directive with the name only or by using the .area pseudo opcode:" },
pre={ Text="#code _HOME         ; following code will be stored in code segment _HOME" },
pre={ Text="      .area _CODE   ; following code will be stored in segment _CODE   (sdcc syntax)" },
p={ Text="You can switch between code segments whenever you like in your source. A typical application is initialization code:" },
p={ Text="You define a segment for init code, e.g. _GSINIT and a segment for most other code, e.g. _CODE. Then at any point in your source where you have some data which need initialization you temporarily switch to the _GSINIT segment and add the init code. This is what the c compiler does for initialized variables." },
h3={ Text="#data",
Keywords={ "#data" } },
pre={ Text="#data <start>,<size>" },
p={ Text="This directive declares an area of ram to be used for variables etc. #data behaves much like #code, except that the contents of this segment is not stored into the output file. The segment is used merely to define labels, presumably in ram." },
p={ Text="For a simple rom written entirely in assembler you probably need only one data segment, or even no data segment at all, if you just define the variables' addresses with the pseudo instruction equ." },
p={ Text="The following example might be used if you include c source:" },
p={ Text="It defines two data segments named _DATA and _INITIALIZED, which is where the c compiler stores uninitialized and initialized variables. In this example these segments are fittet into the 'printer buffer' of the ZX Spectrum, a mostly unused area (except for printing) of 256 bytes. See how the definition of the _INITIALIZED segment directly appends to _DATA and asserts that the combined length does not exceed 256 bytes. The expression <tt>0x100 – (_INITIALIZED – _DATA)</tt> uses the start addresses of the segments for which zasm automatically defines labels." },
h5={ Text="Example:",
Keywords={ "exampl" } },
pre={ Text="#data   _DATA, printer_buffer                           ; uninitialized data\n#data   _INITIALIZED, *, 0x100 - (_INITIALIZED-_DATA)   ; data initialized from _INITIALIZER\n \n#data   _HEAP, code_end     ; heap:\n__sdcc_heap_start:          ; --> sdcc _malloc.c\n        ds  ram_end-$-1     ; add all unused memory to the heap\n__sdcc_heap_end:            ; --> sdcc _malloc.c\n        ds  1" },
p={ Text="<br>A data segment can be re-entered by using the #data directive with the name only or by using the .area pseudo opcode:" },
pre={ Text="#data _DATA         ; following code will be stored in data segment _DATA" },
pre={ Text="      .area _DATA   ; following code will be stored in segment _DATA   (sdcc syntax)" },
p={ Text="<br>You can switch between segments whenever you need to allocate storage space for variables in your source." },
h5={ Text="Example:",
Keywords={ "exampl" } },
pre={ Text="...\n#data   _DATA       ; switch context to data segment _DATA\nfoo     defs    4\nbar     defs    2\nfuzzy   defs    $20\n;\n#code   _CODE       ; switch context back to code segment _CODE\n..." },
p={ Text="<br>The c compiler uses the code segment _INITIALIZER to store the initial data of initialized variables. These are copied during system initialization to the location of _INITIALIZED. (Actually the c compiler doesn't do this. It is your job to add some code in the _GSINIT segment to do this!) So you can switch between these segments to allocate the variable in ram and add init data in rom:" },
h5={ Text="Example:",
Keywords={ "exampl" } },
pre={ Text="...\n#data   _INITIALIZED\nfoo     defs    2       ; allocate space in ram\n#code   _INITIALIZER\n        defw    4711    ; store init t´data in rom. SIZE AND POSITION MUST MATCH!\n#code   _CODE\n..." },
h3={ Text="#include",
Keywords={ "#includ" } },
pre={ Text="#include <\"filename\">" },
p={ Text="Include a source file. The file name must be an absolute path or relative to the main source file. The included source is assembled as if it was in the main source file itself. Source file inclusion may be nested." },
h5={ Text="Examples:",
Keywords={ "exampl" } },
pre={ Text="#include \"utils.ass\"       ; file in same directory\n#include \"./utils.s\"       ; file in same directory\n#include \"utils/u1.s\"      ; file in subdirectory \"utils/\"" },
p={ Text="The included file may be a c source file, which is detected by the filename extension \".c\". Then zasm executes sdcc (or any other c compiler) to compile the source." },
p={ Text="There are certain related topics:" },
ul={ Text="",
Keywords={ } },
li={ Text="Command line option -c may be used to point zasm to a certain compiler.<br>If not used, zasm will search in your $PATH for an executable named 'sdcc'." },
li={ Text="Command line option -I may be used to supply the path to the system headers library.<br>If not used, sdcc will use it's built-in default paths." },
li={ Text="Command line option -L may be used to supply the path to the system library sources.<br>This is used by zasm if you use <tt>#include standard library</tt>. (see below)" },
li={ Text="Directive #CFLAGS may be used in your assembler source to tweak the cflags for the c compiler." },
li={ Text="zasm surrounds included c files with the #local and #endlocal directives to avoid problems with identically named static variables." },
h5={ Text="#include library",
Keywords={ "#includ_library" } },
pre={ Text="#include library <\"directory\">\n#include library <\"directory\"> resolve *\n#include standard library\n#include standard library resolve _foo, __bar, __mulu16" },
p={ Text="<tt>#include library</tt> or <tt>#include standard library</tt> may be used to automatically resolve undefined labels. <tt>#include standard library</tt> requires that you have passed the system library directory with command line option -L." },
p={ Text="You can either try to resolve all missing labels, in which case you don't append the <tt>resolve</tt> keyword or <tt>resolve *</tt>, or you may limit automatic label resolving to a list of certain labels. This may be required if you have to spread the additional code over multiple code segments or if certain labels must go into certain code segments and the included sources do not care for this by themselves." },
p={ Text="This is most conveniant to automatically resolve references arising from c source, but may be used with pure assembler source as well." },
p={ Text="Files in the library directory must follow certain naming conventions: they must be named according to the label they define. If a file defines label _foo, then the file must be named _foo.s or _foo.c, or more accurately any _foo.* will be included. If it ends with '.c' then it will be compiled first." },
p={ Text="zasm adds a checker instruction (#assert) after the included file to verify, that the promissed label was actually defined:" },
h5={ Text="Source:",
Keywords={ "sourc" } },
pre={ Text="#include standard library" },
h5={ Text="Generated:",
Keywords={ "generated" } },
pre={ Text="5E30:                   #include standard library\n5E30:                   #include \"/Projects/sdcc/lib/__mulint.s\"\n5E30:                   ; contents from file\n...                     ...\n7503:                   #assert defined(__mulint::)\n7503:                   #include standard library\n7503:                   #include \"/Projects/sdcc/lib/_check_struct_tm.c\"\n7503:                   #local\n7503:                   ; contents from compiled file\n...                     ...\n8D96:                   #endlocal\n8D96:                   #assert defined(_check_struct_tm::)\n8D96:                   #include standard library\n..." },
p={ Text="You can see how the single <tt>#include standard library</tt> is expanded into a series of <tt>include filename</tt> and an <tt>#assert defined(labelname::)</tt> is appended to the included source. C sources are also wrapped with <tt>#local</tt> .. <tt>#endlocal</tt>." },
h3={ Text="#insert",
Keywords={ "#insert" } },
pre={ Text="#insert <filename>" },
p={ Text="Inserts a binary file. The file name must be given relatively to the main source file's directory." },
p={ Text="The file's contents are just copied into the code segment verbatim." },
h5={ Text="Examples:",
Keywords={ "exampl" } },
pre={ Text="#insert \"image.gif\"       ; file in same directory\n#insert \"./image.gif\"     ; file in same directory\n#insert \"pics/g1.gif\"     ; file in subdirectory \"pics/\"" },
h3={ Text="#if, #elif, #else, #endif",
Keywords={ "#if_#elif_#els_#endif",
"#if",
"#elif",
"#els",
"#endif" } },
pre={ Text="#if <condition>\n    ...\n#elif <condition>\n    ...\n#else\n    ...\n#endif" },
p={ Text="#if starts a block of assembler instructions, which is only assembled if the given <condition> is true. The <condition> must be evaluatable in pass 1. Conditional assembly may be nested to any level. Any assembler directive except pairing #else, #elif and #endif, and any assembler instruction or pseudo instruction is skipped if the <condition> is false. If the pairing #endif is not found until the end of file then a nesting error is assumed. Note, that #include is also skipped if <condition> is false." },
p={ Text="After an #if directive where the <condition> was false, the #elif <condition> is checked and if it is true, the following block is assembled. if it is false, or if already a block was assembled within this #if ... #endif range, the following block is skipped. #elif is optional and may occur multiple times after #if." },
p={ Text="After an #if directive, #else negates the <condition>. If it was false it becomes true and the following assembler instructions are assembled. If it was true it becomes false and the following assembler instructions are skipped. #else is optional and should only occur once before the #endif assembler directive. If #else occurs after some #elif directives, then the #else part is a final 'catch all'." },
p={ Text="The #endif directive finishes conditional assembly as started with the #if directive." },
h3={ Text="#local, #endlocal",
Keywords={ "#local_#endlocal",
"#local",
"#endlocal" } },
p={ Text="This defines all label definitions in the following block as local. That means: all labels defined after #local will be forgotten after the pairing #endlocal. For all those people who like to name their looping points p1, p2, etc." },
h3={ Text="#assert",
Keywords={ "#assert" } },
h3={ Text="#charset",
Keywords={ "#charset" } },
h3={ Text="#cflags",
Keywords={ "#cflag" } },
h3={ Text="#end",
Keywords={ "#end" } },
h2={ Text="Label definitions",
Keywords={ "label_definition",
"label" } },
p={ Text="Any name which starts in the first column and is not an assembler directive (which always starts with a hash '#') or a comment (which always starts with a semicolon ';') is treated as a label definition." },
p={ Text="Maximum length for label names is 9 characters. (v.3.0.16) The label name may be followed by a colon ':'. The assembler has no upper limit for the number of labels." },
p={ Text="There a three different types:" },
ul={ Text="",
Keywords={ } },
li={ Text="defl and equ pseudo instructions assign a calculated value to a name." },
li={ Text="The data pseudo instruction assigns the next address from the #data segment to the name and increments the data pointer by the given size." },
li={ Text="Any label which is not followed by one of the above pseudo instructions, assigns the logical address of the current instruction to it's name. The logical address may be different from the physical address, if you have used the org pseudo instruction or if the #code segment did not start at address $0000. These labels are commonly used to mark target points for jumps, branches and subroutine calls." },
h5={ Text="Examples for label definitions:",
Keywords={ "exampl_for_label_definition" } },
pre={ Text="zahl1   equ     55          ; constant \"zahl1\"  =  55\nHogo:   defl    $+22        ; constant \"Hogo\"   =  address of current instruction +22\nToto    data    4           ; reserves 4 bytes from the #data segment for variable \"Toto\"\nloop1   jp      gaga        ; label \"loop1\"     =  address of current instruction\ngaga:   jr      loop1       ; label \"gaga\"      =  address of current instruction" },
h2={ Text="Z80 Instructions",
Keywords={ "z80_instruction" } },
p={ Text="Z80 instructions must not start in column 1 but must be preceded by 'white space', at minimum one space or one tab, because any word which starts in column 1 is treated as a label definition." },
h3={ Text="Legal instructions",
Keywords={ "legal_instruction",
"opcod",
"z80_opcod" } },
p={ Text="All legal Z80 opcodes are supported." },
pre={ Text="! Opcode    !      A s s e m b l e r   M n e m o n i c   !\n! dec ! hex !   immediate  !  after $CB   !  after $ED   !\n+-----+-----+--------------+--------------+--------------+\n!   0 !  00 ! nop          ! rlc b        !              !\n!   1 !  01 ! ld bc,NN     ! rlc c        !              !\n!   2 !  02 ! ld (bc),a    ! rlc d        !              !\n!   3 !  03 ! inc bc       ! rlc e        !              !\n!   4 !  04 ! inc b        ! rlc h        !              !\n!   5 !  05 ! dec b        ! rlc l        !              !\n!   6 !  06 ! ld b,N       ! rlc (hl)     !              !\n!   7 !  07 ! rlca         ! rlc a        !              !\n+-----+-----+--------------+--------------+--------------+\n!   8 !  08 ! ex af,af'    ! rrc b        !              !\n!   9 !  09 ! add hl,bc    ! rrc c        !              !\n!  10 !  0a ! ld a,(bc)    ! rrc d        !              !\n!  11 !  0b ! dec bc       ! rrc e        !              !\n!  12 !  0c ! inc c        ! rrc h        !              !\n!  13 !  0d ! dec c        ! rrc l        !              !\n!  14 !  0e ! ld c,N       ! rrc (hl)     !              !\n!  15 !  0f ! rrca         ! rrc a        !              !\n+-----+-----+--------------+--------------+--------------+\n!  16 !  10 ! djnz DIS     ! rl b         !              !\n!  17 !  11 ! ld de,NN     ! rl c         !              !\n!  18 !  12 ! ld (de),a    ! rl d         !              !\n!  19 !  13 ! inc de       ! rl e         !              !\n!  20 !  14 ! inc d        ! rl h         !              !\n!  21 !  15 ! dec d        ! rl l         !              !\n!  22 !  16 ! ld d,N       ! rl (hl)      !              !\n!  23 !  17 ! rla          ! rl a         !              !\n+-----+-----+--------------+--------------+--------------+\n!  24 !  18 ! jr DIS       ! rr b         !              !\n!  25 !  19 ! add hl,de    ! rr c         !              !\n!  26 !  1a ! ld a,(de)    ! rr d         !              !\n!  27 !  1b ! dec de       ! rr e         !              !\n!  28 !  1c ! inc e        ! rr h         !              !\n!  29 !  1d ! dec e        ! rr l         !              !\n!  30 !  1e ! ld e,N       ! rr (hl)      !              !\n!  31 !  1f ! rra          ! rr a         !              !\n+-----+-----+--------------+--------------+--------------+\n!  32 !  20 ! jr nz,DIS    ! sla b        !              !\n!  33 !  21 ! ld hl,NN     ! sla c        !              !\n!  34 !  22 ! ld (NN),hl   ! sla d        !              !\n!  35 !  23 ! inc hl       ! sla e        !              !\n!  36 !  24 ! inc h        ! sla h        !              !\n!  37 !  25 ! dec h        ! sla l        !              !\n!  38 !  26 ! ld h,N       ! sla (hl)     !              !\n!  39 !  27 ! daa          ! sla a        !              !\n+-----+-----+--------------+--------------+--------------+\n!  40 !  28 ! jr z,DIS     ! sra b        !              !\n!  41 !  29 ! add hl,hl    ! sra c        !              !\n!  42 !  2a ! ld hl,(NN)   ! sra d        !              !\n!  43 !  2b ! dec hl       ! sra e        !              !\n!  44 !  2c ! inc l        ! sra h        !              !\n!  45 !  2d ! dec l        ! sra l        !              !\n!  46 !  2e ! ld l,N       ! sra (hl)     !              !\n!  47 !  2f ! cpl          ! sra a        !              !\n+-----+-----+--------------+--------------+--------------+\n!  48 !  30 ! jr nc,DIS    ! sll b  (ill.)!              !\n!  49 !  31 ! ld sp,NN     ! sll c     \"\" !              !\n!  50 !  32 ! ld (NN),a    ! sll d     \"\" !              !\n!  51 !  33 ! inc sp       ! sll e     \"\" !              !\n!  52 !  34 ! inc (hl)     ! sll h     \"\" !              !\n!  53 !  35 ! dec (hl)     ! sll l     \"\" !              !\n!  54 !  36 ! ld (hl),N    ! sll (hl)  \"\" !              !\n!  55 !  37 ! scf          ! sll a     \"\" !              !\n+-----+-----+--------------+--------------+--------------+\n!  56 !  38 ! jr c,DIS     ! srl b        !              !\n!  57 !  39 ! add hl,sp    ! srl c        !              !\n!  58 !  3a ! ld a,(NN)    ! srl d        !              !\n!  59 !  3b ! dec sp       ! srl e        !              !\n!  60 !  3c ! inc a        ! srl h        !              !\n!  61 !  3d ! dec a        ! srl l        !              !\n!  62 !  3e ! ld a,N       ! srl (hl)     !              !\n!  63 !  3f ! ccf          ! srl a        !              !\n+-----+-----+--------------+--------------+--------------+\n!  64 !  40 ! ld b,b       ! bit 0,b      ! in b,(c)     !\n!  65 !  41 ! ld b,c       ! bit 0,c      ! out (c),b    !\n!  66 !  42 ! ld b,d       ! bit 0,d      ! sbc hl,bc    !\n!  67 !  43 ! ld b,e       ! bit 0,e      ! ld (NN),bc   !\n!  68 !  44 ! ld b,h       ! bit 0,h      ! neg          !\n!  69 !  45 ! ld b,l       ! bit 0,l      ! retn         !\n!  70 !  46 ! ld b,(hl)    ! bit 0,(hl)   ! im 0         !\n!  71 !  47 ! ld b,a       ! bit 0,a      ! ld i,a       !\n+-----+-----+--------------+--------------+--------------+\n!  72 !  48 ! ld c,b       ! bit 1,b      ! in c,(c)     !\n!  73 !  49 ! ld c,c       ! bit 1,c      ! out (c),c    !\n!  74 !  4a ! ld c,d       ! bit 1,d      ! adc hl,bc    !\n!  75 !  4b ! ld c,e       ! bit 1,e      ! ld bc,(NN)   !\n!  76 !  4c ! ld c,h       ! bit 1,h      !              !\n!  77 !  4d ! ld c,l       ! bit 1,l      ! reti         !\n!  78 !  4e ! ld c,(hl)    ! bit 1,(hl)   !              !\n!  79 !  4f ! ld c,a       ! bit 1,a      ! ld r,a       !\n+-----+-----+--------------+--------------+--------------+\n!  80 !  50 ! ld d,b       ! bit 2,b      ! in d,(c)     !\n!  81 !  51 ! ld d,c       ! bit 2,c      ! out (c),d    !\n!  82 !  52 ! ld d,d       ! bit 2,d      ! sbc hl,de    !\n!  83 !  53 ! ld d,e       ! bit 2,e      ! ld (NN),de   !\n!  84 !  54 ! ld d,h       ! bit 2,h      !              !\n!  85 !  55 ! ld d,l       ! bit 2,l      !              !\n!  86 !  56 ! ld d,(hl)    ! bit 2,(hl)   ! im 1         !\n!  87 !  57 ! ld d,a       ! bit 2,a      ! ld a,i       !\n+-----+-----+--------------+--------------+--------------+\n!  88 !  58 ! ld e,b       ! bit 3,b      ! in e,(c)     !\n!  89 !  59 ! ld e,c       ! bit 3,c      ! out (c),e    !\n!  90 !  5a ! ld e,d       ! bit 3,d      ! adc hl,de    !\n!  91 !  5b ! ld e,e       ! bit 3,e      ! ld de,(NN)   !\n!  92 !  5c ! ld e,h       ! bit 3,h      !              !\n!  93 !  5d ! ld e,l       ! bit 3,l      !              !\n!  94 !  5e ! ld e,(hl)    ! bit 3,(hl)   ! im 2         !\n!  95 !  5f ! ld e,a       ! bit 3,a      ! ld a,r       !\n+-----+-----+--------------+--------------+--------------+\n!  96 !  60 ! ld h,b       ! bit 4,b      ! in h,(c)     !\n!  97 !  61 ! ld h,c       ! bit 4,c      ! out (c),h    !\n!  98 !  62 ! ld h,d       ! bit 4,d      ! sbc hl,hl    !\n!  99 !  63 ! ld h,e       ! bit 4,e      ! ld (NN),hl   !\n! 100 !  64 ! ld h,h       ! bit 4,h      !              !\n! 101 !  65 ! ld h,l       ! bit 4,l      !              !\n! 102 !  66 ! ld h,(hl)    ! bit 4,(hl)   !              !\n! 103 !  67 ! ld h,a       ! bit 4,a      ! rrd          !\n+-----+-----+--------------+--------------+--------------+\n! 104 !  68 ! ld l,b       ! bit 5,b      ! in l,(c)     !\n! 105 !  69 ! ld l,c       ! bit 5,c      ! out (c),l    !\n! 106 !  6a ! ld l,d       ! bit 5,d      ! adc hl,hl    !\n! 107 !  6b ! ld l,e       ! bit 5,e      ! ld hl,(NN)   !\n! 108 !  6c ! ld l,h       ! bit 5,h      !              !\n! 109 !  6d ! ld l,l       ! bit 5,l      !              !\n! 110 !  6e ! ld l,(hl)    ! bit 5,(hl)   !              !\n! 111 !  6f ! ld l,a       ! bit 5,a      ! rld          !\n+-----+-----+--------------+--------------+--------------+\n! 112 !  70 ! ld (hl),b    ! bit 6,b      ! in f,(c)     !\n! 113 !  71 ! ld (hl),c    ! bit 6,c      !              !\n! 114 !  72 ! ld (hl),d    ! bit 6,d      ! sbc hl,sp    !\n! 115 !  73 ! ld (hl),e    ! bit 6,e      ! ld (NN),sp   !\n! 116 !  74 ! ld (hl),h    ! bit 6,h      !              !\n! 117 !  75 ! ld (hl),l    ! bit 6,l      !              !\n! 118 !  76 ! halt         ! bit 6,(hl)   !              !\n! 119 !  77 ! ld (hl),a    ! bit 6,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 120 !  78 ! ld a,b       ! bit 7,b      ! in a,(c)     !\n! 121 !  79 ! ld a,c       ! bit 7,c      ! out (c),a    !\n! 122 !  7a ! ld a,d       ! bit 7,d      ! adc hl,sp    !\n! 123 !  7b ! ld a,e       ! bit 7,e      ! ld sp,(NN)   !\n! 124 !  7c ! ld a,h       ! bit 7,h      !              !\n! 125 !  7d ! ld a,l       ! bit 7,l      !              !\n! 126 !  7e ! ld a,(hl)    ! bit 7,(hl)   !              !\n! 127 !  7f ! ld a,a       ! bit 7,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 128 !  80 ! add a,b      ! res 0,b      !              !\n! 129 !  81 ! add a,c      ! res 0,c      !              !\n! 130 !  82 ! add a,d      ! res 0,d      !              !\n! 131 !  83 ! add a,e      ! res 0,e      !              !\n! 132 !  84 ! add a,h      ! res 0,h      !              !\n! 133 !  85 ! add a,l      ! res 0,l      !              !\n! 134 !  86 ! add a,(hl)   ! res 0,(hl)   !              !\n! 135 !  87 ! add a,a      ! res 0,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 136 !  88 ! adc a,b      ! res 1,b      !              !\n! 137 !  89 ! adc a,c      ! res 1,c      !              !\n! 138 !  8a ! adc a,d      ! res 1,d      !              !\n! 139 !  8b ! adc a,e      ! res 1,e      !              !\n! 140 !  8c ! adc a,h      ! res 1,h      !              !\n! 141 !  8d ! adc a,l      ! res 1,l      !              !\n! 142 !  8e ! adc a,(hl)   ! res 1,(hl)   !              !\n! 143 !  8f ! adc a,a      ! res 1,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 144 !  90 ! sub b        ! res 2,b      !              !\n! 145 !  91 ! sub c        ! res 2,c      !              !\n! 146 !  92 ! sub d        ! res 2,d      !              !\n! 147 !  93 ! sub e        ! res 2,e      !              !\n! 148 !  94 ! sub h        ! res 2,h      !              !\n! 149 !  95 ! sub l        ! res 2,l      !              !\n! 150 !  96 ! sub (hl)     ! res 2,(hl)   !              !\n! 151 !  97 ! sub a        ! res 2,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 152 !  98 ! sbc a,b      ! res 3,b      !              !\n! 153 !  99 ! sbc a,c      ! res 3,c      !              !\n! 154 !  9a ! sbc a,d      ! res 3,d      !              !\n! 155 !  9b ! sbc a,e      ! res 3,e      !              !\n! 156 !  9c ! sbc a,h      ! res 3,h      !              !\n! 157 !  9d ! sbc a,l      ! res 3,l      !              !\n! 158 !  9e ! sbc a,(hl)   ! res 3,(hl)   !              !\n! 159 !  9f ! sbc a,a      ! res 3,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 160 !  a0 ! and b        ! res 4,b      ! ldi          !\n! 161 !  a1 ! and c        ! res 4,c      ! cpi          !\n! 162 !  a2 ! and d        ! res 4,d      ! ini          !\n! 163 !  a3 ! and e        ! res 4,e      ! outi         !\n! 164 !  a4 ! and h        ! res 4,h      !              !\n! 165 !  a5 ! and l        ! res 4,l      !              !\n! 166 !  a6 ! and (hl)     ! res 4,(hl)   !              !\n! 167 !  a7 ! and a        ! res 4,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 168 !  a8 ! xor b        ! res 5,b      ! ldd          !\n! 169 !  a9 ! xor c        ! res 5,c      ! cpd          !\n! 170 !  aa ! xor d        ! res 5,d      ! ind          !\n! 171 !  ab ! xor e        ! res 5,e      ! outd         !\n! 172 !  ac ! xor h        ! res 5,h      !              !\n! 173 !  ad ! xor l        ! res 5,l      !              !\n! 174 !  ae ! xor (hl)     ! res 5,(hl)   !              !\n! 175 !  af ! xor a        ! res 5,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 176 !  b0 ! or b         ! res 6,b      ! ldir         !\n! 177 !  b1 ! or c         ! res 6,c      ! cpir         !\n! 178 !  b2 ! or d         ! res 6,d      ! inir         !\n! 179 !  b3 ! or e         ! res 6,e      ! otir         !\n! 180 !  b4 ! or h         ! res 6,h      !              !\n! 181 !  b5 ! or l         ! res 6,l      !              !\n! 182 !  b6 ! or (hl)      ! res 6,(hl)   !              !\n! 183 !  b7 ! or a         ! res 6,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 184 !  b8 ! cp b         ! res 7,b      ! lddr         !\n! 185 !  b9 ! cp c         ! res 7,c      ! cpdr         !\n! 186 !  ba ! cp d         ! res 7,d      ! indr         !\n! 187 !  bb ! cp e         ! res 7,e      ! otdr         !\n! 188 !  bc ! cp h         ! res 7,h      !              !\n! 189 !  bd ! cp l         ! res 7,l      !              !\n! 190 !  be ! cp (hl)      ! res 7,(hl)   !              !\n! 191 !  bf ! cp a         ! res 7,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 192 !  c0 ! ret nz       ! set 0,b      !              !\n! 193 !  c1 ! pop bc       ! set 0,c      !              !\n! 194 !  c2 ! jp nz,NN     ! set 0,d      !              !\n! 195 !  c3 ! jp NN        ! set 0,e      !              !\n! 196 !  c4 ! call nz,NN   ! set 0,h      !              !\n! 197 !  c5 ! push bc      ! set 0,l      !              !\n! 198 !  c6 ! add a,N      ! set 0,(hl)   !              !\n! 199 !  c7 ! rst 0        ! set 0,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 200 !  c8 ! ret z        ! set 1,b      !              !\n! 201 !  c9 ! ret          ! set 1,c      !              !\n! 202 !  ca ! jp z,NN      ! set 1,d      !              !\n! 203 !  cb ! PREFIX col.2 ! set 1,e      !              !\n! 204 !  cc ! call z,NN    ! set 1,h      !              !\n! 205 !  cd ! call NN      ! set 1,l      !              !\n! 206 !  ce ! adc a,NN     ! set 1,(hl)   !              !\n! 207 !  cf ! rst 8        ! set 1,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 208 !  d0 ! ret nc       ! set 2,b      !              !\n! 209 !  d1 ! pop de       ! set 2,c      !              !\n! 210 !  d2 ! jp nc,NN     ! set 2,d      !              !\n! 211 !  d3 ! out (N),a    ! set 2,e      !              !\n! 212 !  d4 ! call nc,NN   ! set 2,h      !              !\n! 213 !  d5 ! push de      ! set 2,l      !              !\n! 214 !  d6 ! sub N        ! set 2,(hl)   !              !\n! 215 !  d7 ! rst 16       ! set 2,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 216 !  d8 ! ret c        ! set 3,b      !              !\n! 217 !  d9 ! exx          ! set 3,c      !              !\n! 218 !  da ! jp c,NN      ! set 3,d      !              !\n! 219 !  db ! in a,(N)     ! set 3,e      !              !\n! 220 !  dc ! call c,NN    ! set 3,h      !              !\n! 221 !  dd ! PREFIX IX    ! set 3,l      !              !\n! 222 !  de ! sbc a,N      ! set 3,(hl)   !              !\n! 223 !  df ! rst 24       ! set 3,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 224 !  e0 ! ret po       ! set 4,b      !              !\n! 225 !  e1 ! pop hl       ! set 4,c      !              !\n! 226 !  e2 ! jp po,NN     ! set 4,d      !              !\n! 227 !  e3 ! ex (sp),hl   ! set 4,e      !              !\n! 228 !  e4 ! call po,NN   ! set 4,h      !              !\n! 229 !  e5 ! push hl      ! set 4,l      !              !\n! 230 !  e6 ! and N        ! set 4,(hl)   !              !\n! 231 !  e7 ! rst 32       ! set 4,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 232 !  e8 ! ret pe       ! set 5,b      !              !\n! 233 !  e9 ! jp (hl)      ! set 5,c      !              !\n! 234 !  ea ! jp pe,NN     ! set 5,d      !              !\n! 235 !  eb ! ex de,hl     ! set 5,e      !              !\n! 236 !  ec ! call pe,NN   ! set 5,h      !              !\n! 237 !  ed ! PREFIX col.3 ! set 5,l      !              !\n! 238 !  ee ! xor N        ! set 5,(hl)   !              !\n! 239 !  ef ! rst 40       ! set 5,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 240 !  f0 ! ret p        ! set 6,b      !              !\n! 241 !  f1 ! pop af       ! set 6,c      !              !\n! 242 !  f2 ! jp p,NN      ! set 6,d      !              !\n! 243 !  f3 ! di           ! set 6,e      !              !\n! 244 !  f4 ! call p,NN    ! set 6,h      !              !\n! 245 !  f5 ! push af      ! set 6,l      !              !\n! 246 !  f6 ! or N         ! set 6,(hl)   !              !\n! 247 !  f7 ! rst 48       ! set 6,a      !              !\n+-----+-----+--------------+--------------+--------------+\n! 248 !  f8 ! ret m        ! set 7,b      !              !\n! 249 !  f9 ! ld sp,hl     ! set 7,c      !              !\n! 250 !  fa ! jp m,NN      ! set 7,d      !              !\n! 251 !  fb ! ei           ! set 7,e      !              !\n! 252 !  fc ! call m,NN    ! set 7,h      !              !\n! 253 !  fd ! PREFIX IY    ! set 7,l      !              !\n! 254 !  fe ! cp N         ! set 7,(hl)   !              !\n! 255 !  ff ! rst 56       ! set 7,a      !              !\n+-----+-----+--------------+--------------+--------------+" },
h3={ Text="Illegal instructions",
Keywords={ "illegal_instruction",
"illegal_opcod" } },
p={ Text="The following illegal instructions are recognized:" },
h4={ Text="sll",
Keywords={ "sll" } },
p={ Text="shift left register A, padding bit 0 with '1'" },
p={ Text="<i>This presumably should have been padding bit 0 with '0', complementing the srl instruction, but when Zilog found out that their delivered cpus had a bug and actually padded bit 0 with '1', they fixed it by removing the opcode from the specs. :-| Just guessing.</i>" },
h4={ Text="XL, XH, YL and YH",
Keywords={ "xl_xh_yl_and",
"xl",
"xh",
"yl",
"yh" } },
p={ Text="Since version 3.0.15 zasm supports illegal instructions which use XL, XH, YL or YH instead of register L and H in the byte instructions:" },
p={ Text="<b>cp, or, ld, and, xor, sub, sbc, adc</b><br><b>inc, dec</b> (since vs.3.0.17)" },
p={ Text="e.g.:" },
pre={ Text="    ld  a,xh\n    or  xl" },
p={ Text="generates:" },
pre={ Text="    defb    prefix_ix\n    defb    opcode_ld_a_h\n    defb    prefix_ix\n    defb    opcode_or_a_h" },
h3={ Text="Syntax variants",
Keywords={ "syntax_variant",
"syntax_variation" } },
p={ Text="Besides of the official Zilog Z80 assembler syntax, the following variations of their syntax are allowed:" },
pre={ Text="out (c),reg     out (bc),reg\nin  reg,(c)     in  reg,(bc)\n\nadd x           add a,x\nsub x           sub a,x\nadc x           adc a,x\nsbc x           sbc a,x\nand x           and a,x\nor  x           or  a,x\nxor x           xor a,x\ncp  x           cp  a,x\n\nrst 0           rst 0\nrst 1           rst 8\nrst 2           rst 16\nrst 3           rst 24\nrst 4           rst 32\nrst 5           rst 40\nrst 6           rst 48\nrst 7           rst 56\n\nld  bc,de\nld  bc,hl\nld  de,bc\nld  de,hl\nld  hl,bc\nld  hl,de" },
h2={ Text="Pseudo instructions",
Keywords={ "pseudo_instruction" } },
p={ Text="Pseudo instructions are instructions like 'org' or 'defs', which are written at the place of a Z80 assembler instruction but which are not Z80 instructions. Some pseudo instructions generate code, others don't." },
p={ Text="Z80 and pseudo instructions must not start in column 1, because then the assembler will assume a label definition. Instructions are always preceded by 'white space', at minimum one space or one tab." },
h3={ Text="org",
Keywords={ "org" } },
pre={ Text="org <value>" },
p={ Text="The org pseudo instruction defines a new logical origin for the generated code. The code generation pointer is not moved, but all subsequent generated code is generated for the new logical origin. This comes in handy if you write routines or a jump table which you want to move around in memory later. All labels defined after the org pseudo instruction refer to the new logical origin. The dollar sign '$' in expressions refers to the logical origin too. Normally you don't need the org pseudo instruction, because you set the origin when you define a code segment with the #code assembler directive." },
p={ Text="If you actually want to move the code generation pointer to that new position and fill the unused space with $00 or the like, then you can use defs:" },
h5={ Text="Example: advance code deposition pointer",
Keywords={ "exampl_advanc_cod_deposition" } },
pre={ Text="; ------------------------------------------------------\n            ...                 ; some code\n            pop     af\n            ret\n\n            defs    $66 - $     ; advance to address $66\nnmi_vek:    ...\n\n; ------------------------------------------------------" },
h5={ Text="Example: relocated jump table",
Keywords={ "exampl_relocated_jump_tabl",
"relocat",
"relocatabl",
"relocator" } },
pre={ Text="; ------------------------------------------------------\n            ...                 ; some code\n            ccf\n            ret\n\nrom_table:  org     $FE00       ; label based on old org\nram_table:                      ; label based on new org\n\nputchar:    jp      putchar_rom\nputtext:    jp      puttext_rom\ngetchar:    jp      getchar_rom\ngetline:    jp      getline_rom\n\ntable_size: equ     $ - ram_table\n\n; back to old origin\n            org     rom_table + table_size\n\ngizmo:      ld      de,ram_table\n            ld      hl,rom_table\n            ld      bc,table_size\n            ldir\n\n            ld  a,0             ; more code\n            ...\n\n; ------------------------------------------------------" },
p={ Text="<b>note:</b> in version 3.0.5 and 3.0.6 the org pseudo instruction behaved differently!" },
h3={ Text="data",
Keywords={ "data" } },
p={ Class="i",
Text="TODO: the following is for zasm version 3.0." },
pre={ Text="<label>: data <value>" },
p={ Text="The pseudo instruction 'data' assigns the current value of the data segment pointer to the <label> and reserves <value> bytes from the data segment defined with the #data assembler directive. If data allocation exceeds the size given in the #data assembler directive, the assembler reports an error." },
h5={ Text="Example:",
Keywords={ "exampl" } },
pre={ Text="...\n#data   $4000,$100\n...\n\nticks   data    3\nfoo     data    4\nbar     data    4\ncheese  data    $20\n..." },
h3={ Text="defw, dw",
Keywords={ "defw_dw",
"defw",
"dw" } },
pre={ Text="defw <value>[,<value>...]\ndw   <value>[,<value>...]" },
p={ Text="Same as 'defb' but for words (double bytes). Words are stored with their least significant byte first! This means, $1234 is stored as $34, $12 and 'ab' is stored as 'b','a'. If you don't like this, try using the defm pseudo instruction." },
h3={ Text="defb, defm, db, dm",
Keywords={ "defb_defm_db_dm",
"defb",
"db",
"defm",
"dm" } },
p={ Text="Since version 3.0.16 the functionality of defb and defm are merged. Any vombination of data which was valid for either of both can now be used with any of both." },
pre={ Text="defb <value>[,<value>...]\ndb   <value>[,<value>...]" },
p={ Text="The defb pseudo instruction evaluates the argument expressions and puts them one byte after the other into the code segment." },
pre={ Text="defm <text>[,<text>]\ndm   <text>[,<text>]" },
p={ Text="Stores a string of text into the code segment. The text string may be given in the following formats:" },
pre={ Text="$12345678....   packed hex string\n12345678h       packed hex string\n'text'          text string, delimited by <'>, must not contain <'>\n\"text\"          text string, delimited by <\">, must not contain <\">" },
p={ Text="The hex bytes or ascii bytes are stored in the same order as they appear in the string, e.g. $1234 is stored as $12,$34 and 'ab' is stored as 'a','b'." },
p={ Text="The last byte of a packed hex string or a text string may be modified by an expression; commonly used is setting bit 7 of the last character of a message:" },
pre={ Text="defm   \"this is my message\"+$80" },
p={ Text="There are three predefined names for text strings:" },
pre={ Text="__date__        current date:     \"Jan.31.96\"\n__time__        current time:     \"23:56:30\"\n__file__        current file name \"filename.ext\"" },
h3={ Text="defs, ds",
Keywords={ "def_ds",
"def",
"ds" } },
pre={ Text="defs <value1>[,<value2>]\nds   <value1>[,<value2>]" },
p={ Text="This pseudo instruction inserts a block of <value1> bytes into the code segment. The default fill pattern is $FF for ROMs and $00 for all other target formats. If you append a <value2>, this byte is used as pattern instead." },
p={ Text="Within a #head segment the default values for the header data are used by defs if no second value is given." },
h3={ Text="defl, equ",
Keywords={ "defl_equ",
"defl",
"equ" } },
pre={ Text="<label>:  defl  <value>\n<label>:  equ   <value>" },
p={ Text="These two pseudo instructions do quite the same and are used to assign a value to a name. The expression needs not to be evaluatable in the first pass but if possible it is." },
h2={ Text="Expressions",
Keywords={ "expression" } },
p={ Text="The assembler has an expression evaluator which supports various formats for numbers and operations with priority order. You may also use brackets, but don't start an expression for an immediate value with an opening bracket. The assembler thinks that an expression which starts with an opening bracket indicates direct memory addressing. If you really need to start an immediate value expression with brackets, precede it with the '+' monadic operator." },
h3={ Text="$ (dollar sign)",
Keywords={ "dollar_sign",
"dollar" } },
p={ Text="The dollar sign '$' refers to the logical address of the first byte of the current instruction. The logical address may differ from the physical location if you have used the org pseudo instruction to move the logical origin." },
h3={ Text="Number literals",
Keywords={ "numb_literal" } },
pre={ Text="12345    decimal number\n$1234    hexadecimal number\n1234h    hexadecimal number\n%1010    binary number\n1010b    binary number\n'ab'     note: 'b' goes to the lower address, 'a' to the higher" },
h3={ Text="Operators",
Keywords={ "operator",
"operator_priority",
"priority" } },
p={ Text="The following operators are recognized and listed in order of precedence:" },
pre={ Text="brackets            ( ... )\nmonadic operators   + - ~           plus sign, minus sign, 2's complement\nshifting            << >>           shift left or right; left operand is target\nboolean             & | ^           bitwise and, or, xor\nmult/div            * / \\ %         multiply, divide, remainder, remainder\nadd/sub             + -             add, subtract\ncomparisions        > < >= <= = <>  greater than etc.; result is $0000 or $FFFF\n                    == !=           <i>equal</i> and <i>not equal</i> (since v.3.0.15)." },
h1={ Text="Target files",
Keywords={ "target_fil",
"destination_fil",
"output_fil" } },
h3={ Text="General rules",
Keywords={ "general_rul" } },
p={ Text="The target file format must be set with the #target assembler directive." },
pre={ Text="#target <extension>" },
p={ Text="#target defines extension and format of the target file. There must be only one #target section per assembler source." },
p={ Text="This does not define whether the generated data should be written as a plain binary file or in intel hex file format. This must be selected be the '-b' or '-x' command line option. The assembler always defaults to binary except if the output is written to a terminal." },
p={ Text="Up to version 0.3.13 the #target assembler directive is required." },
p={ Text="Since version 0.3.14 the #target assembler directive may be omitted. Then the default target format is <b>rom</b>." },
pre={ Text="#head       <size>" },
p={ Text="Target files which store registers and similar information start with a #head segment. The data within the #head segment are set using 'defb' and similar instructions. If portions of the #head segment are not set or 'defs' is used with no fill pattern then default values will be filled in which vary depending on the omitted data's purpose." },
pre={ Text="#code       <start>,<size>" },
p={ Text="This directive defines an object code segment and set's the initial logical code origin to <start> and defines a maximum segment size <size>." },
p={ Text="<start> does not neccessarily define the physical position of the code segment in the rom. Binary output does not contain address information, just the pure data. In contrast Intel hex files contain address information. Starting with <i>version 3.0.13</i> addresses in hex files are biased to <start>. The 'org' assembler pseudo instruction does not affect the hex file addresses." },
p={ Text="Multiple code segments are possible and are simply concatenated. Code segments are either padded at the end to the declared maximum segment size or they are truncated, depending on the #target format." },
p={ Text="Up to version 0.3.13 the #code assembler directive is required." },
p={ Text="Since version 0.3.14 the #code assembler directive may be omitted. Then the used default values are <b>start=0</b> and <b>size=$10000</b>." },
h5={ Text="Intel hex file format",
Keywords={ "intel_hex_fil_format" } },
p={ Text="If the file is saved in the intel hex file format, then the unused space at the end of all code segments is never saved (truncated). When reading these files you can decide what to do with the missing data. e.g. an eprom burner will simply skip over the gaps, leaving the data as is, probably $FF for erased cells." },
p={ Text="As stated above, Intel hex files contain address information at which to physically store the generated code. Starting with <i>zasm version 3.0.13</i> this address is also set to <start>." },
h5={ Text="Binary files",
Keywords={ "binary_fil" } },
p={ Text="All code segments are padded with $00 to the declared maximum size, except:" },
ul={ Text="",
Keywords={ } },
li={ Text="ROM: all code segments are padded with $FF" },
li={ Text="ROM: the last code segment is truncated" },
li={ Text="BIN: the last code segment is truncated" },
li={ Text="TAP: all code segments are truncated" },
li={ Text="80:  the last code segment is truncated<br>same applies to \"81\",
\"o\" and \"p\"" },
p={ Text="If you want to prevent that a code segment is truncated then you can simply add 'defs' to fill it up to the last byte." },
p={ Text="Binary files do not contain information about the address where they should be loaded. Where they are loaded purely depends on the application used to load the file into a simulator or eprom." },
h3={ Text="#target rom",
Keywords={ "#target_rom",
"rom" } },
p={ Text="This file is a plain rom or eprom image." },
p={ Text="Segments are padded with $FF, except for the last code segment, which is not padded but truncated." },
pre={ Text="#target     rom\n#code       <start>,<len>\n        ...\n#end" },
h3={ Text="#target bin",
Keywords={ "#target_bin",
"bin" } },
p={ Text="Pretty the same as a rom file, but rather expected to be loaded somewhere into ram." },
p={ Text="Segments are padded with $00, except for the last code segment, which is not padded but truncated." },
pre={ Text="#target     bin\n#code       <start>,<len>\n        ...\n#end" },
h3={ Text="#target sna",
Keywords={ "#target_sna",
"sna" } },
p={ Text="Information on the ZX Spectrum file formats can be found in the ZX Spectrum FAQ which can be found on WOS:  <http://www.worldofspectrum.org/faq/>." },
p={ Text="A ZX Spectrum snapshot file. This consists of a ram dump from location $4000 to $FFFF. Snapshot files also contain information about the machine state, most namely the Z80 registers. The #head assembler directive is required to set interrupt mode and all Z80 registers." },
pre={ Text="#target sna\n#head   27\n    ...\n#code   <start>,<len>\n    ...\n#end" },
p={ Text="The SNA snapshot file describes a ZX Spectrum 16k or 48k serving an nmi request." },
p={ Text="<start> should be $4000 and <len> should be $4000 or $C000. at least later it's loaded that way. when #end is reached, the file is padded with $00 to $4000 bytes (if possible) or $C000 bytes, which implicitely defines a ZX Spectrum 16k or ZX Spectrum 48k." },
p={ Text="The RAM contents are written to the file in the uncompressed SNA format. the SNA file format is an NMI snapshot. the instruction pointer PC is not stored in the header section but on the return stack in RAM." },
h5={ Text="Default values for header data:",
Keywords={ "default_valu_for_head" } },
pre={ Text="defb    $3f         ; i\ndefw    0,0,0,0     ; hl',de',bc',af'\ndefw    0,0,0,0,0   ; hl,de,bc,iy,ix\ndefb    $04         ; bit 2 = iff2 (iff1 before nmi) 0=di, 1=ei\ndefb    0,0,0       ; r,f,a\ndefw    0           ; sp\ndefb    1           ; irpt mode\ndefb    7           ; border color: 0=black ... 7=white" },
h3={ Text="#target z80",
Keywords={ "#target_z80",
"z80" } },
p={ Text="Information on the ZX Spectrum file formats can be found in the ZX Spectrum FAQ which can be found on WOS:  <http://www.worldofspectrum.org/faq/>." },
p={ Text="This ZX Spectrum snapshot format may contain a snapshot for the ZX Spectrum or the ZX 128. It contains all of the .sna file's information and optionally some more. It is preferred over the .sna format by some people, because it does not store the instruction pointer pc on the Z80 machine stack. The .z80 file may also contain one or two roms and data for the paged ram of the ZX 128." },
pre={ Text="#target z80\n#head   <size>      ; vs.201 = 55;  vs.300 = 86;  xzx = 87\n#code   <start>,<len>\n    ...\n#page   <index>\n    ...\n#end" },
p={ Text="The z80 format describes a ZX Spectrum 16k, 48k, 128k or, in versions written by the warajewo and xzx emulator, a Timex 2068, a ZX Spectrum +3, a Pentagon or a Scorpion." },
p={ Text="The object code from the code segments is written to the paged-in RAM according to the value stored for the paging control register at address $1FFD. start should be $4000, len should be $4000 or $C000. at least, this is how it get's loaded later." },
p={ Text="Note:  $4000 = bank 5;   $8000 = bank 2;   $C000 = bank 0 after reset." },
p={ Text="The #page directive defines a RAM page in which the following object code is stored. it set's start to $C000 and len to $4000. this directive is only allowed for models which are capable of paging." },
p={ Text="The RAM contents are written to the file in the compressed Z80 format." },
h5={ Text="Default values for header data:",
Keywords={ "default_valu_for_head" } },
pre={ Text="    defb    0,0         ; a,f\n    defw    0,0         ; bc,hl\n    defw    0           ; flag idicating vs.201 header or later\n    defw    0,0         ; sp\n    defb    $3f         ; i\n    defb    0           ; r & 0x7f\n    defb    (7<<1)      ; (r>>7) + (border_color<<1)\n    defw    0,0,0,0     ; de,bc',de',hl'\n    defb    0,0         ; a',f'\n    defw    0,0         ; iy,ix\n    defb    1           ; iff1: 0=di, 1=ei\n    defb    1           ; iff2\n    defb    1+(1<<6)    ; (irpt_mode) + (issue_2<<2) + (joystick_emu<<6)\n// vs.201 header:\n    defw    headsize-32 ; size of header extension; should be 23 or 54\n    defw    0           ; pc\n    defb    0           ; ZX Spectrum model     1)\n    defb    0           ; 128k: last out to $7ffd (bank switching)  2)\n    defb    0           ; if1 paged in?     2)\n    defb    7           ; proper r and ldir emulation, 48k ay emulation 3)\n    defb    0           ; last out to $fffd (ay register select)\n    defs    16,$ff      ; ay registers\n// vs.300 header:\n    defb    0,0,0       ; T state counters\n    defb    0           ; misc.\n    defb    0,0,$ff,$ff ; MGT/Multiface/SamRam paging\n    defs    20,0        ; keyboard mapping for joystick emulation\n    defb    0,0,0       ; Disciple flags\n// xzx header extension:\n    defb    0           ; +3: last out to $1ffd (bank switching)    3)\n\n1)  0   = 48k\n    3   = 128k in vs.201\n    4   = 128k in vs.300\n    128 = Timex 2068        (warajewo)\n    7   = +3                (xzx)\n    9   = pentagon          (xzx)\n    10  = scorpion          (xzx)   16 ram pages!\n\n2)  Timex 2068:\n    last out to 244\n    last out to 255\n\n3)  Bit 2: enable ay emulation even in 48k mode (xzx)" },
h3={ Text="#target tape",
Keywords={ "#target_tap",
"tap" } },
p={ Text="A ZX Spectrum tape file. This file may and should contain several code segments. Any time a #code segment is finished, it is appended to the tape file." },
pre={ Text="#target     tape\n#code       <start>,<len>,<flag>\n    ...\n#end" },
p={ Text="The tape file format represents programs and data saved to a music compact cassette by the original ZX Spectrum tape saving routines." },
p={ Text="Each code segment defines a block on the tape. the flag argument defines the type of block, which is typically $00 for a header block and $FF for the subsequent data block." },
p={ Text="The code segments are never padded but always truncated. the blocks are written to the file in the uncompressed TAP format." },
p={ Text="Any kind of data is typically saved in two blocks: a header block, containing information about the following data, and a data block, containing data as described by the preceding header." },
p={ Text="A complete game is typically saved in two parts: a basic loader, which consists of a header and a data block and the machine code part, which consists of a header and data block too." },
p={ Text="All blocks in the .tap file start with two bytes specifying how many bytes will follow. Then raw tape data follows, starting with the flag byte and ending with the checksum byte. A tape file is a simple sequence of any number of these blocks." },
h5={ Text="Layout of a block in a tape file:",
Keywords={ "layout_of_a_block" } },
pre={ Text="defw    <length>\ndefb    <flag>\ndefm    <data>\ndefb    <checksum>" },
h5={ Text="<length>",
Keywords={ "<length>" } },
p={ Text="This is the number of bytes that follow: including the <flag>, <data> and <checksum>; not counting the <length> itself. Byte order is little endian, this means, the low byte is first. The ZX Spectrum save routine cannot save 0 bytes or more than $ff00 bytes, thus the minimum <length> is 3, which means 1 byte flag + 1 byte data + 1 byte checksum." },
h5={ Text="<flag>",
Keywords={ "<flag>" } },
p={ Text="This is the value of the A register when the ZX Spectrum save routine was called. A value of $00 normally indicates, that this is a header block, a value of $FF indicates, that this is a data block, which contents are described by the preceding header block." },
h5={ Text="<data>",
Keywords={ "<data>" } },
p={ Text="Contains a header (if <flag>==$00 and <length>==19) or data. These are the bytes which will be loaded into RAM." },
h5={ Text="<checksum>",
Keywords={ "<checksum>" } },
p={ Text="this is the bitwise XOR of all bytes including the flag byte." },
p={ Text="To create a program which consists of a basic loader and a machine code part as described above, write an assembler program which consist of 4 code segments:" },
ul={ Text="",
Keywords={ } },
li={ Text="a 'program' header block for the basic loader" },
li={ Text="the data block containing the basic program" },
li={ Text="a 'code' header block for the binary data" },
li={ Text="the data block containing the machine code" },
p={ Text="A header block is always 17 bytes long." },
p={ Text="The headers for a basic program and for binary data are layed out as follows:" },
h5={ Text="Header for basic program:",
Keywords={ "head_for_basic_program" } },
pre={ Text="defb    0       ; this indicates a basic program\ndefm    name    ; the 'file' name, 10 bytes long\ndefw    length  ; length of block, that is basic program plus variables\ndefw    auto    ; line number for auto-start, $8000 if none\ndefw    proglen ; length of the basic program without variables" },
h5={ Text="Header for binary data:",
Keywords={ "head_for_binary_data" } },
pre={ Text="defb    3       ; this indicates binary data\ndefm    name    ; the 'file' name, 10 bytes long\ndefw    length  ; length of data block which follows\ndefw    origin  ; original location from where the binary data was saved\ndefw    0       ; unused" },
h5={ Text="A sample framework for a tape file assembler source:",
Keywords={ "a_sampl_framework_for" } },
pre={ Text=";****** TAPE FILE ASSEMBLER SOURCE SAMPLE ************************************\nheaderflag:     equ 0\ndataflag:       equ $ff\n\ntCLEAR  equ     $FD             ; token CLEAR\ntLOAD   equ     $EF             ; token LOAD\ntCODE   equ     $AF             ; token CODE\ntPRINT  equ     $F5             ; token PRINT\ntUSR    equ     $C0             ; token USR\n\n#target tap\n\n;------ PROGRAM HEADER -------------------------------------------------------\n#code   0,17,headerflag\n        defb    0               ; program\n        defm    \"testloader\"    ; make sure these are 10 bytes!\n        defw    programsize     ; length of basic program and variables\n        defw    10              ; line number for auto start\n        defw    programsize     ; length of basic program without variables\n\n\n;------ PROGRAM DATA ---------------------------------------------------------\n#code   0,$100,dataflag         ; size is truncated as required\n\n; 10 CLEAR 24000\n        defb    0,10                    ; line number\n        defb    end10-($+1)             ; line length\n        defb    0                       ; statement number\n        defb    tCLEAR                  ; token CLEAR\n        defm    '24000',$0e0000c05d00   ; number 24000, ascii & internal format\nend10:  defb    $0d                     ; line end marker\n\n; 20 LOAD \"\" CODE 24000\n        defb    0,20                    ; line number\n        defb    end20-($+1)             ; line length\n        defb    0                       ; statement number\n        defb    tLOAD,'\"','\"',tCODE     ; token LOAD, 2 quotes, token CODE\n        defm    '24000',$0e0000c05d00   ; number 24000, ascii & internal format\nend20:  defb    $0d                     ; line end marker\n\n; 30 PRINT USR 24000\n        defb    0,30                    ; line number\n        defb    end30-($+1)             ; line length\n        defb    0                       ; statement number\n        defb    tPRINT,tUSR             ; token PRINT, token USR\n        defm    '24000',$0e0000c05d00   ; number 24000, ascii & internal format\nend30:  defb    $0d                     ; line end marker\nprogramsize     equ     $\n\n\n;------ CODE HEADER ----------------------------------------------------------\n#code   0,17,headerflag\n\n        defb    3               ; code\n        defm    \"samplecode\"    ; make sure these are 10 bytes!\n        defw    codeend-24000   ; length of data block\n        defw    24000           ; original position\n        defw    0               ; unused\n\n\n;------ CODE DATA ------------------------------------------------------------\n#code   24000,40000,dataflag\n\n        ret                     ; insert your machine code here\n\ncodeend:\n#end\n;****** END OF CODE SAMPLE ***************************************************" },
h3={ Text="#target 80 / #target o",
Keywords={ "#target_#target_o" } },
p={ Text="This creates a tape file for use with an ZX80 emulator. There is only one #code segment allowed, which is not padded but truncated. The tape file will allways be loaded to ram start at address $4000." },
pre={ Text="#target 80\n#code   <start>,<len>\n    ...\n#end" },
p={ Text="\"o\" can be used instead of \"80\". This will create a target file with extension \"o\" or \"80\" respectively, which are fully identical." },
p={ Text="The tape data is always loaded to $4000, so this is the only choice for the <start> address in the #code directive. The <size> may be any value up to a maximum of $C000, but note that most ZX80 had maximum 16 kB ram if extended with an external memory expansion, only 1 kB if none." },
p={ Text="The ram starts with system variables from $4000 to $4028, which must be set to proper values. The variable E_LINE at $400A, which contains the end of ram address, is set by the assembler. You need not to calculate it, just skip it with \"defs 2\" or \"defw 0\"." },
h3={ Text="#target 81 / #target p",
Keywords={ "#target_#target_p" } },
p={ Text="This creates a tape file for use with an ZX81 emulator. There is only one #code segment allowed, which is not padded but truncated. The tape file will allways be loaded to ram start + $09 at address $4009." },
pre={ Text="#target 81\n#code   <start>,<len>\n    ...\n#end" },
p={ Text="\"p\" can be used instead of \"81\". This will create a target file with extension \"p\" or \"81\" respectively, which are fully identical." },
p={ Text="The tape data is always loaded to $4009, so this is the only choice for the <start> address in the #code directive. The <size> may be any value up to a maximum of $C000 minus $09, but note that most ZX81 had maximum 16 kB ram if extended with an external memory expansion, only 1 kB if none." },
p={ Text="The ram starts with system variables from $4009 to $403C, which must be set to proper values. The variable E_LINE at the address $4014, which contains the end of ram address, is set by the assembler. You need not to calculate it, just skip it with \"defs 2\" or \"defw 0\"." },
p={ Text="This file also contains the screen file, which basically means, that the video memory must contain 25 HALT opcodes if the file was saved in SLOW mode." },
h6={ Text="Here are few important variables:",
Keywords={ "her_ar_few_important" } },
pre={ Text="$4014   defines the end address (used to calculate the file length)\n$4029   points to the next executed (autostarted) BASIC line\n$403B   bit 6 indicates if program runs in SLOW or FAST mode\n$403C++ may be misused for whatever purpose" },
h3={ Text="#target ace",
Keywords={ "#target_ac" } },
p={ Text="TODO" },
h1={ Text="Version history",
Keywords={ "version_history" } },
pre={ Text="1.0.0  1996: First version for private use. Mac OS 7.0. No public release.\n2.0.0  2000: Total rework with new libraries.\n2.0.7  2002: started port of MacOS classic version to unix\n3.0.0  2002: MacOS X command line version released\n3.0.2        .tap and .sna support implemented\n3.0.13 2005: #code statement now also sets the physical address for intel hex files\n3.0.14       #target, #end and #code now optional. default target = rom\n3.0.15       added illegals with XL,XH,YL,YH to: cp, or, ld, and, xor, sub, sbc, adc\n4.0.0  2014: rewrite with more C++ inside\n4.0.0  2014: .tap .sna .z80 .o .p .ace\n4.0.0  2014: c compiler support\n4.0.0  2014: rework of segment handling\n4.0.0  2014: #local #endlocal\n4.0.0  2014: #charset\n4.0.0  2014: #assert and directive '!' for self test\n4.0.0  2014: 8080 and HD64180 support\n4.0.0  2014: list accumulated cpu cycles\n4.0.1  2014: write Motorola S-Record files" } }
